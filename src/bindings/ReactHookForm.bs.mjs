// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Curry from "rescript/lib/es6/curry.js";
import * as React from "react";
import * as Caml_option from "rescript/lib/es6/caml_option.js";
import * as ReactHookForm from "react-hook-form";
import * as JsxRuntime from "react/jsx-runtime";

function sync(syncHandler) {
  return syncHandler;
}

function async(asyncHandler) {
  return asyncHandler;
}

var Validation = {
  sync: sync,
  async: async
};

function empty(param) {
  
}

function make(config) {
  return config;
}

function makeWithErrorMessage(config) {
  return config;
}

function merge(a, b) {
  return Object.assign(Object.assign({}, a), b);
}

var Rules = {
  empty: empty,
  make: make,
  makeWithErrorMessage: makeWithErrorMessage,
  merge: merge
};

var Register = {};

var UnRegister = {};

var $$Error = {};

function Make(Form) {
  var createResolverFromResult = function (resolver, data) {
    var data$p = Curry._1(resolver, data);
    if (data$p.TAG === /* Ok */0) {
      return {
              values: data$p._0,
              errors: {}
            };
    } else {
      return {
              values: data,
              errors: data$p._0
            };
    }
  };
  var MakeInput = function (T) {
    var makeRule = function (config) {
      return config;
    };
    var makeRuleWithErrorMessage = function (config) {
      return config;
    };
    var useWatch = function (form) {
      return ReactHookForm.useWatch({
                  control: form.control,
                  name: T.name
                });
    };
    var watch = function (form) {
      return form.watch(T.name);
    };
    var getValue = function (form) {
      return form.getValues(T.name);
    };
    var setValue = function (form, value) {
      form.setValue(T.name, value, undefined);
    };
    var setValueWithOption = function (form, value, shouldValidate, shouldDirty, shouldTouch) {
      var partial_arg = {
        shouldValidate: shouldValidate,
        shouldDirty: shouldDirty,
        shouldTouch: shouldTouch
      };
      return function (param) {
        form.setValue(T.name, value, partial_arg !== undefined ? Caml_option.valFromOption(partial_arg) : undefined);
      };
    };
    var resetField = function (form) {
      form.resetField(T.name);
    };
    var setError = function (form, error) {
      form.setError(T.name, error);
    };
    var setErrorShouldFocus = function (form, error) {
      form.setError(T.name, error, { shouldFocus: true });
    };
    var createError = function (type_, message) {
      return [
              T.name,
              {
                message: message,
                type: type_
              }
            ];
    };
    var focus = function (form) {
      form.setFocus(T.name);
    };
    var focusShouldSelect = function (form) {
      form.setFocus(T.name, { shouldSelect: true });
    };
    var getFieldState = function (form) {
      return form.getFieldState(T.name, form.formState);
    };
    var error = function (form) {
      return getFieldState(form).error;
    };
    var isDirty = function (form) {
      return getFieldState(form).isDirty;
    };
    var isTouched = function (form) {
      return getFieldState(form).isTouched;
    };
    var invalid = function (form) {
      return getFieldState(form).invalid;
    };
    var clearError = function (form) {
      form.clearErrors(T.name);
    };
    var trigger = function (form) {
      return form.trigger(T.name);
    };
    var unregister = function (form, config) {
      form.unregister(T.name, config);
    };
    var Controller = {};
    var renderController = function (form, render, defaultValue, rules, shouldUnregister, param) {
      return JsxRuntime.jsx(ReactHookForm.Controller, {
                  name: T.name,
                  control: form.control,
                  render: render,
                  defaultValue: defaultValue,
                  rules: Caml_option.some(merge(T.config, rules)),
                  shouldUnregister: shouldUnregister
                });
    };
    var useController = function (form, rules, shouldUnregister, param) {
      return ReactHookForm.useController({
                  name: T.name,
                  control: form.control,
                  rules: rules,
                  shouldUnregister: shouldUnregister
                });
    };
    var triggerWithFocus = function (form) {
      return form.trigger(T.name, {shouldFocus: true});
    };
    var register = function (form, config, param) {
      return form.register(T.name, Caml_option.some(merge(T.config, config)));
    };
    var renderWithRegister = function (form, element, config, param) {
      return React.cloneElement(element, register(form, Caml_option.some(config), undefined));
    };
    return {
            makeRule: makeRule,
            makeRuleWithErrorMessage: makeRuleWithErrorMessage,
            useWatch: useWatch,
            watch: watch,
            getValue: getValue,
            setValue: setValue,
            setValueWithOption: setValueWithOption,
            resetField: resetField,
            setError: setError,
            setErrorShouldFocus: setErrorShouldFocus,
            createError: createError,
            focus: focus,
            focusShouldSelect: focusShouldSelect,
            getFieldState: getFieldState,
            error: error,
            isDirty: isDirty,
            isTouched: isTouched,
            invalid: invalid,
            clearError: clearError,
            trigger: trigger,
            unregister: unregister,
            Controller: Controller,
            renderController: renderController,
            useController: useController,
            triggerWithFocus: triggerWithFocus,
            register: register,
            renderWithRegister: renderWithRegister
          };
  };
  var MakeInputArray = function (T) {
    var name = T.name;
    var config = T.config;
    var makeRule = function (config) {
      return config;
    };
    var makeRuleWithErrorMessage = function (config) {
      return config;
    };
    var useWatch = function (form) {
      return ReactHookForm.useWatch({
                  control: form.control,
                  name: name
                });
    };
    var watch = function (form) {
      return form.watch(name);
    };
    var getValue = function (form) {
      return form.getValues(name);
    };
    var setValue = function (form, value) {
      form.setValue(name, value, undefined);
    };
    var setValueWithOption = function (form, value, shouldValidate, shouldDirty, shouldTouch) {
      var partial_arg = {
        shouldValidate: shouldValidate,
        shouldDirty: shouldDirty,
        shouldTouch: shouldTouch
      };
      return function (param) {
        form.setValue(name, value, partial_arg !== undefined ? Caml_option.valFromOption(partial_arg) : undefined);
      };
    };
    var resetField = function (form) {
      form.resetField(name);
    };
    var setError = function (form, error) {
      form.setError(name, error);
    };
    var setErrorShouldFocus = function (form, error) {
      form.setError(name, error, { shouldFocus: true });
    };
    var createError = function (type_, message) {
      return [
              name,
              {
                message: message,
                type: type_
              }
            ];
    };
    var focus = function (form) {
      form.setFocus(name);
    };
    var focusShouldSelect = function (form) {
      form.setFocus(name, { shouldSelect: true });
    };
    var getFieldState = function (form) {
      return form.getFieldState(name, form.formState);
    };
    var error = function (form) {
      return getFieldState(form).error;
    };
    var isDirty = function (form) {
      return getFieldState(form).isDirty;
    };
    var isTouched = function (form) {
      return getFieldState(form).isTouched;
    };
    var invalid = function (form) {
      return getFieldState(form).invalid;
    };
    var clearError = function (form) {
      form.clearErrors(name);
    };
    var trigger = function (form) {
      return form.trigger(name);
    };
    var unregister = function (form, config) {
      form.unregister(name, config);
    };
    var Controller = {};
    var renderController = function (form, render, defaultValue, rules, shouldUnregister, param) {
      return JsxRuntime.jsx(ReactHookForm.Controller, {
                  name: name,
                  control: form.control,
                  render: render,
                  defaultValue: defaultValue,
                  rules: Caml_option.some(merge(config, rules)),
                  shouldUnregister: shouldUnregister
                });
    };
    var useController = function (form, rules, shouldUnregister, param) {
      return ReactHookForm.useController({
                  name: name,
                  control: form.control,
                  rules: rules,
                  shouldUnregister: shouldUnregister
                });
    };
    var triggerWithFocus = function (form) {
      return form.trigger(name, {shouldFocus: true});
    };
    var register = function (form, config$1, param) {
      return form.register(name, Caml_option.some(merge(config, config$1)));
    };
    var renderWithRegister = function (form, element, config, param) {
      return React.cloneElement(element, register(form, Caml_option.some(config), undefined));
    };
    var useFieldArray = function (form, config, param) {
      return ReactHookForm.useFieldArray({
                  control: form.control,
                  name: T.name
                }, Caml_option.some(merge(T.config, config)));
    };
    var registerWithIndex = function (form, index, config, propertyOpt, param) {
      var property = propertyOpt !== undefined ? propertyOpt : "";
      return form.register("" + T.name + "." + String(index) + "" + (
                  property !== "" ? "." + property + "" : ""
                ) + "", Caml_option.some(merge(T.config, config)));
    };
    var renderWithIndexRegister = function (form, index, element, propertyOpt, config, param) {
      var property = propertyOpt !== undefined ? propertyOpt : "";
      return React.cloneElement(element, registerWithIndex(form, index, Caml_option.some(config), property, undefined));
    };
    return {
            makeRule: makeRule,
            makeRuleWithErrorMessage: makeRuleWithErrorMessage,
            useWatch: useWatch,
            watch: watch,
            getValue: getValue,
            setValue: setValue,
            setValueWithOption: setValueWithOption,
            resetField: resetField,
            setError: setError,
            setErrorShouldFocus: setErrorShouldFocus,
            createError: createError,
            focus: focus,
            focusShouldSelect: focusShouldSelect,
            getFieldState: getFieldState,
            error: error,
            isDirty: isDirty,
            isTouched: isTouched,
            invalid: invalid,
            clearError: clearError,
            trigger: trigger,
            unregister: unregister,
            Controller: Controller,
            renderController: renderController,
            useController: useController,
            triggerWithFocus: triggerWithFocus,
            register: register,
            renderWithRegister: renderWithRegister,
            useFieldArray: useFieldArray,
            registerWithIndex: registerWithIndex,
            renderWithIndexRegister: renderWithIndexRegister
          };
  };
  var Context = {};
  var P = {};
  var ReactHookForm$Make$Provider$SpreadProps = function (props) {
    return React.cloneElement(props.children, props.props);
  };
  var SpreadProps = {
    make: ReactHookForm$Make$Provider$SpreadProps
  };
  var ReactHookForm$Make$Provider = function (props) {
    return JsxRuntime.jsx(ReactHookForm$Make$Provider$SpreadProps, {
                children: JsxRuntime.jsx(ReactHookForm.FormProvider, {
                      children: props.children
                    }),
                props: props.methods
              });
  };
  var Provider = {
    P: P,
    SpreadProps: SpreadProps,
    make: ReactHookForm$Make$Provider
  };
  return {
          createResolverFromResult: createResolverFromResult,
          MakeInput: MakeInput,
          MakeInputArray: MakeInputArray,
          Context: Context,
          Provider: Provider
        };
}

export {
  Validation ,
  Rules ,
  Register ,
  UnRegister ,
  $$Error ,
  Make ,
}
/* react Not a pure module */
